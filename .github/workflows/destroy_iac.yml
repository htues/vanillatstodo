name: "Destroy IaC Resources"

"on":
  workflow_dispatch:
    inputs:
      confirmation:
        description: "Type 'destroy' to confirm"
        required: true
        type: string
      environment:
        description: "Environment to destroy (staging/production)"
        required: true
        type: choice
        options:
          - staging
          - production
          - experimental
        default: "staging"

permissions:
  contents: read
  id-token: write

env:
  CLUSTER_NAME: "vanillatstodo-cluster"
  BUCKET_NAME: "vanillatstodo-terraform-state"
  AWS_REGION: "us-east-2"
  TF_VERSION: "1.10.0"
  PROJECT_NAME: "vanillatstodo"
  ENVIRONMENT: ${{ github.event.inputs.environment }}

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  destroy:
    timeout-minutes: 30
    name: "Destroy Infrastructure"
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.confirmation == 'destroy' }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Destroy State Resources
        id: state
        run: |
          cd devops/terraform/00_state
          terraform init -reconfigure \
            -backend-config="bucket=${{ env.BUCKET_NAME }}" \
            -backend-config="key=${{ env.ENVIRONMENT }}/state/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="encrypt=true"
          terraform destroy -auto-approve \
            -var="aws_region=${{ env.AWS_REGION }}" \
            -var="project_name=${{ env.PROJECT_NAME }}" \
            -var="environment=${{ env.ENVIRONMENT }}"

      - name: Destroy EKS Resources
        id: eks_cleanup
        run: |
          cd devops/terraform/02_eks
          terraform init -reconfigure \
            -backend-config="bucket=${{ env.BUCKET_NAME }}" \
            -backend-config="key=${{ env.ENVIRONMENT }}/eks/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="encrypt=true"
          
          # Check if network state exists and has outputs
          echo "ðŸ” Checking network state availability..."
          NETWORK_STATE_EXISTS=$(aws s3api head-object \
            --bucket ${{ env.BUCKET_NAME }} \
            --key ${{ env.ENVIRONMENT }}/network/terraform.tfstate 2>/dev/null && echo "true" || echo "false")
          
          echo "ðŸ“Š Network state exists: $NETWORK_STATE_EXISTS"
          
          if [ "$NETWORK_STATE_EXISTS" = "false" ]; then
            echo "âš ï¸ Network state not found. Checking if EKS resources exist directly..."
            
            # Check if EKS cluster exists directly
            CLUSTER_EXISTS=$(aws eks describe-cluster \
              --name ${{ env.CLUSTER_NAME }} \
              --query 'cluster.name' \
              --output text 2>/dev/null || echo "false")
            
            echo "ðŸ“Š EKS cluster exists: $CLUSTER_EXISTS"
            
            if [ "$CLUSTER_EXISTS" = "${{ env.CLUSTER_NAME }}" ]; then
              echo "âš ï¸ EKS cluster exists but network state is missing. Attempting direct cleanup..."
              
              # Try to destroy with -refresh=false to skip state reading
              terraform destroy -auto-approve -refresh=false \
                -var="cluster_name=${{ env.CLUSTER_NAME }}" \
                -var="aws_region=${{ env.AWS_REGION }}" \
                -var="project_name=${{ env.PROJECT_NAME }}" \
                -var="environment=${{ env.ENVIRONMENT }}" \
                -var="cluster_role_name=${{ env.ENVIRONMENT == 'production' && 'production-vanillatstodo-cluster-role' || 'staging-vanillatstodo-cluster-role' }}" || true
            else
              echo "âœ… EKS cluster not found. Skipping EKS destruction."
            fi
          else
            echo "âœ… Network state found. Checking if it contains required outputs..."
            
            # Download and check network state content
            aws s3 cp s3://${{ env.BUCKET_NAME }}/${{ env.ENVIRONMENT }}/network/terraform.tfstate /tmp/network_state.json
            
            # Check if state has outputs
            HAS_OUTPUTS=$(jq -r '.outputs // empty' /tmp/network_state.json 2>/dev/null || echo "false")
            HAS_VPC_ID=$(jq -r '.outputs.vpc_id.value // empty' /tmp/network_state.json 2>/dev/null || echo "false")
            
            echo "ðŸ“Š Network state has outputs: $HAS_OUTPUTS"
            echo "ðŸ“Š Network state has vpc_id: $HAS_VPC_ID"
            
            if [ "$HAS_OUTPUTS" = "false" ] || [ "$HAS_VPC_ID" = "false" ] || [ "$HAS_VPC_ID" = "null" ] || [ "$HAS_VPC_ID" = "" ]; then
              echo "âš ï¸ Network state exists but is empty or missing required outputs. Skipping Terraform EKS destruction."
              echo "ðŸ”„ Will rely on manual EKS cleanup step instead."
              echo "âœ… EKS Terraform destruction skipped successfully."
              # Set a flag to indicate we're skipping Terraform EKS destruction
              echo "SKIP_TERRAFORM_EKS=true" >> $GITHUB_ENV
            else
              echo "âœ… Network state has required outputs. Proceeding with normal EKS destruction..."
              echo "SKIP_TERRAFORM_EKS=false" >> $GITHUB_ENV
              
              # Check for and force unlock any stale locks
              echo "ðŸ”“ Checking for stale state locks..."
              if terraform plan -detailed-exitcode >/dev/null 2>&1; then
                echo "âœ… No state lock detected"
              else
                echo "âš ï¸ State lock detected, attempting to force unlock..."
                # Try to get the lock ID from the error message
                LOCK_ID=$(terraform plan 2>&1 | grep -o 'ID: [a-f0-9-]*' | cut -d' ' -f2 || echo "")
                if [ ! -z "$LOCK_ID" ]; then
                  echo "ðŸ”“ Force unlocking with ID: $LOCK_ID"
                  terraform force-unlock -force "$LOCK_ID"
                else
                  echo "âš ï¸ Could not determine lock ID, trying generic unlock..."
                  terraform force-unlock -force f2e10d17-e3da-6e08-aef1-7a64455b038d || true
                fi
              fi
              
              terraform destroy -auto-approve \
                -var="cluster_name=${{ env.CLUSTER_NAME }}" \
                -var="aws_region=${{ env.AWS_REGION }}" \
                -var="project_name=${{ env.PROJECT_NAME }}" \
                -var="environment=${{ env.ENVIRONMENT }}" \
                -var="cluster_role_name=${{ env.ENVIRONMENT == 'production' && 'production-vanillatstodo-cluster-role' || 'staging-vanillatstodo-cluster-role' }}"
            fi
          fi

      - name: Manual EKS Cleanup (if needed)
        id: manual_eks_cleanup
        run: |
          echo "ðŸ” Checking for any remaining EKS resources..."
          
          # Check for EKS clusters
          CLUSTERS=$(aws eks list-clusters --query "clusters[?contains(@, '${{ env.CLUSTER_NAME }}')]" --output text)
          if [ ! -z "$CLUSTERS" ] && [ "$CLUSTERS" != "None" ]; then
            echo "âš ï¸ Found EKS clusters: $CLUSTERS"
            
            for cluster in $CLUSTERS; do
              echo "ðŸ—‘ï¸ Deleting EKS cluster: $cluster"
              
              # Delete node groups first
              NODE_GROUPS=$(aws eks list-nodegroups --cluster-name $cluster --query "nodegroups" --output text 2>/dev/null || echo "")
              if [ ! -z "$NODE_GROUPS" ] && [ "$NODE_GROUPS" != "None" ]; then
                echo "ðŸ—‘ï¸ Deleting node groups for cluster $cluster: $NODE_GROUPS"
                for ng in $NODE_GROUPS; do
                  aws eks delete-nodegroup --cluster-name $cluster --nodegroup-name $ng || true
                done
                
                # Wait for node groups to be deleted
                echo "â³ Waiting for node groups to be deleted..."
                sleep 60
              fi
              
              # Delete the cluster
              aws eks delete-cluster --name $cluster || true
            done
          else
            echo "âœ… No EKS clusters found"
          fi
          
          # Check for EKS-related security groups
          echo "ðŸ” Checking for EKS-related security groups..."
          EKS_SGS=$(aws ec2 describe-security-groups \
            --filters "Name=group-name,Values=*eks*" "Name=tag:Project,Values=${{ env.PROJECT_NAME }}" \
            --query 'SecurityGroups[*].GroupId' \
            --output text)
          
          if [ ! -z "$EKS_SGS" ] && [ "$EKS_SGS" != "None" ]; then
            echo "ðŸ—‘ï¸ Found EKS security groups: $EKS_SGS"
            for sg in $EKS_SGS; do
              echo "ðŸ—‘ï¸ Deleting security group: $sg"
              aws ec2 delete-security-group --group-id $sg || true
            done
          fi
          
          # Check for EKS-related VPC endpoints
          echo "ðŸ” Checking for EKS-related VPC endpoints..."
          VPC_IDS=$(aws ec2 describe-vpcs \
            --filters "Name=tag:Name,Values=*vanillatstodo*" \
            --query 'Vpcs[*].VpcId' \
            --output text)
          
          for VPC_ID in $VPC_IDS; do
            EKS_ENDPOINTS=$(aws ec2 describe-vpc-endpoints \
              --filters "Name=vpc-id,Values=$VPC_ID" "Name=service-name,Values=com.amazonaws.*.eks" \
              --query 'VpcEndpoints[*].VpcEndpointId' \
              --output text)
            
            if [ ! -z "$EKS_ENDPOINTS" ] && [ "$EKS_ENDPOINTS" != "None" ]; then
              echo "ðŸ—‘ï¸ Found EKS VPC endpoints: $EKS_ENDPOINTS"
              aws ec2 delete-vpc-endpoints --vpc-endpoint-ids $EKS_ENDPOINTS || true
            fi
          done
                    
          # Wait a bit for resources to be fully deleted
          echo "â³ Waiting for EKS resources to be fully deleted..."
          sleep 30

      - name: Wait for EKS Resources to be Fully Deleted
        id: wait_for_eks_cleanup
        run: |
          echo "â³ Waiting for EKS resources to be fully deleted..."
          sleep 60
          
          # Check if there are any remaining EKS-related resources
          echo "ðŸ” Checking for remaining EKS resources..."
          
          # Check for EKS clusters
          CLUSTERS=$(aws eks list-clusters --query "clusters[?contains(@, '${{ env.CLUSTER_NAME }}')]" --output text)
          if [ ! -z "$CLUSTERS" ] && [ "$CLUSTERS" != "None" ]; then
            echo "âš ï¸ Found remaining EKS clusters: $CLUSTERS"
            echo "â³ Waiting additional 2 minutes for cluster deletion..."
            sleep 120
          else
            echo "âœ… No remaining EKS clusters found"
          fi
          
          # Check for EKS node groups
          NODE_GROUPS=$(aws eks list-nodegroups --cluster-name ${{ env.CLUSTER_NAME }} --query "nodegroups" --output text 2>/dev/null || echo "")
          if [ ! -z "$NODE_GROUPS" ] && [ "$NODE_GROUPS" != "None" ]; then
            echo "âš ï¸ Found remaining EKS node groups: $NODE_GROUPS"
            echo "â³ Waiting additional 2 minutes for node group deletion..."
            sleep 120
          else
            echo "âœ… No remaining EKS node groups found"
          fi

      - name: Destroy Monitoring Resources
        id: monitoring_cleanup
        run: |
          cd devops/terraform/03_monitoring
          terraform init -reconfigure \
            -backend-config="bucket=${{ env.BUCKET_NAME }}" \
            -backend-config="key=${{ env.ENVIRONMENT }}/monitoring/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="encrypt=true"
          terraform destroy -auto-approve \
            -var="aws_region=${{ env.AWS_REGION }}" \
            -var="project_name=${{ env.PROJECT_NAME }}" \
            -var="environment=${{ env.ENVIRONMENT }}"

      - name: Enhanced Network Dependency Cleanup
        id: enhanced_network_cleanup
        run: |
          echo "ðŸ” Performing enhanced network dependency cleanup..."
          
          # Find all VPCs with our project tags
          VPC_IDS=$(aws ec2 describe-vpcs \
            --filters "Name=tag:Name,Values=*vanillatstodo*" \
            --query 'Vpcs[*].VpcId' \
            --output text)
          
          for VPC_ID in $VPC_IDS; do
            echo "ðŸ” Cleaning up dependencies for VPC: $VPC_ID"
            
            # 1. Delete all VPC endpoints
            echo "ðŸ—‘ï¸ Deleting all VPC endpoints..."
            ENDPOINTS=$(aws ec2 describe-vpc-endpoints \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'VpcEndpoints[*].VpcEndpointId' \
              --output text)
            
            if [ ! -z "$ENDPOINTS" ] && [ "$ENDPOINTS" != "None" ]; then
              echo "ðŸ—‘ï¸ Found VPC endpoints: $ENDPOINTS"
              aws ec2 delete-vpc-endpoints --vpc-endpoint-ids $ENDPOINTS || true
              sleep 30
            fi
            
            # 2. Delete all network interfaces
            echo "ðŸ—‘ï¸ Deleting all network interfaces..."
            ENI_IDS=$(aws ec2 describe-network-interfaces \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'NetworkInterfaces[*].NetworkInterfaceId' \
              --output text)
            
            if [ ! -z "$ENI_IDS" ] && [ "$ENI_IDS" != "None" ]; then
              echo "ðŸ—‘ï¸ Found network interfaces: $ENI_IDS"
              for eni in $ENI_IDS; do
                ENI_STATUS=$(aws ec2 describe-network-interfaces \
                  --network-interface-ids $eni \
                  --query 'NetworkInterfaces[0].Status' \
                  --output text)
                if [ "$ENI_STATUS" = "available" ]; then
                  echo "ðŸ—‘ï¸ Deleting available network interface: $eni"
                  aws ec2 delete-network-interface --network-interface-id $eni || true
                  sleep 5
                else
                  echo "âš ï¸ Network interface $eni is not available (status: $ENI_STATUS)"
                fi
              done
            fi
            
            # 3. Delete all security groups (except default)
            echo "ðŸ—‘ï¸ Deleting all security groups..."
            SG_IDS=$(aws ec2 describe-security-groups \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'SecurityGroups[?GroupName!=`default`].GroupId' \
              --output text)
            
            if [ ! -z "$SG_IDS" ] && [ "$SG_IDS" != "None" ]; then
              echo "ðŸ—‘ï¸ Found security groups: $SG_IDS"
              for sg in $SG_IDS; do
                aws ec2 delete-security-group --group-id $sg || true
                sleep 2
              done
            fi
            
            # 4. Delete all route table associations and route tables
            echo "ðŸ—‘ï¸ Deleting route table associations..."
            RT_IDS=$(aws ec2 describe-route-tables \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'RouteTables[?Associations[0].Main!=`true`].RouteTableId' \
              --output text)
            
            if [ ! -z "$RT_IDS" ] && [ "$RT_IDS" != "None" ]; then
              echo "ðŸ—‘ï¸ Found route tables: $RT_IDS"
              for rt in $RT_IDS; do
                # Disassociate all associations first
                ASSOC_IDS=$(aws ec2 describe-route-tables \
                  --route-table-id $rt \
                  --query 'RouteTables[0].Associations[*].RouteTableAssociationId' \
                  --output text)
                
                for assoc in $ASSOC_IDS; do
                  aws ec2 disassociate-route-table --association-id $assoc || true
                done
                
                # Delete the route table
                aws ec2 delete-route-table --route-table-id $rt || true
                sleep 2
              done
            fi
            
            # 5. Delete all NAT gateways
            echo "ðŸ—‘ï¸ Deleting NAT gateways..."
            NAT_IDS=$(aws ec2 describe-nat-gateways \
              --filter "Name=vpc-id,Values=$VPC_ID" \
              --query 'NatGateways[?State!=`deleted`].NatGatewayId' \
              --output text)
            
            if [ ! -z "$NAT_IDS" ] && [ "$NAT_IDS" != "None" ]; then
              echo "ðŸ—‘ï¸ Found NAT gateways: $NAT_IDS"
              for nat in $NAT_IDS; do
                aws ec2 delete-nat-gateway --nat-gateway-id $nat || true
              done
              
              # Wait for NAT gateways to be deleted
              if [ ! -z "$NAT_IDS" ]; then
                echo "â³ Waiting for NAT gateways to be deleted..."
                sleep 45
              fi
            fi
            
            # 6. Delete all network ACLs (except default)
            echo "ðŸ—‘ï¸ Deleting network ACLs..."
            NACL_IDS=$(aws ec2 describe-network-acls \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'NetworkAcls[?!IsDefault].NetworkAclId' \
              --output text)
            
            if [ ! -z "$NACL_IDS" ] && [ "$NACL_IDS" != "None" ]; then
              echo "ðŸ—‘ï¸ Found network ACLs: $NACL_IDS"
              for nacl in $NACL_IDS; do
                aws ec2 delete-network-acl --network-acl-id $nacl || true
                sleep 2
              done
            fi
            
            # 7. Delete all subnets
            echo "ðŸ—‘ï¸ Deleting all subnets..."
            SUBNET_IDS=$(aws ec2 describe-subnets \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'Subnets[*].SubnetId' \
              --output text)
            
            if [ ! -z "$SUBNET_IDS" ] && [ "$SUBNET_IDS" != "None" ]; then
              echo "ðŸ—‘ï¸ Found subnets: $SUBNET_IDS"
              for subnet in $SUBNET_IDS; do
                aws ec2 delete-subnet --subnet-id $subnet || true
                sleep 2
              done
            fi
            
            # 8. Delete internet gateway
            echo "ðŸ—‘ï¸ Deleting internet gateway..."
            IGW_ID=$(aws ec2 describe-internet-gateways \
              --filters "Name=attachment.vpc-id,Values=$VPC_ID" \
              --query 'InternetGateways[*].InternetGatewayId' \
              --output text)
            
            if [ ! -z "$IGW_ID" ] && [ "$IGW_ID" != "None" ]; then
              echo "ðŸ—‘ï¸ Found internet gateway: $IGW_ID"
              aws ec2 detach-internet-gateway --internet-gateway-id $IGW_ID --vpc-id $VPC_ID || true
              aws ec2 delete-internet-gateway --internet-gateway-id $IGW_ID || true
              sleep 2
            fi
            
            echo "âœ… Completed dependency cleanup for VPC: $VPC_ID"
          done
          
          echo "â³ Waiting for all resources to be fully deleted..."
          sleep 30

      - name: Destroy Network Resources
        id: network_cleanup
        run: |
          cd devops/terraform/01_network
          terraform init -reconfigure \
            -backend-config="bucket=${{ env.BUCKET_NAME }}" \
            -backend-config="key=${{ env.ENVIRONMENT }}/network/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="encrypt=true"
          
          echo "ðŸš€ Proceeding with network destruction..."
          terraform destroy -auto-approve \
            -var="aws_region=${{ env.AWS_REGION }}" \
            -var="project_name=${{ env.PROJECT_NAME }}" \
            -var="environment=${{ env.ENVIRONMENT }}"

      - name: Clean Up CloudWatch Resources
        id: cloudwatch_cleanup
        run: |
          echo "ðŸ” Finding CloudWatch resources..."

          # Delete CloudWatch Dashboard
          echo "ðŸ—‘ï¸ Deleting CloudWatch Dashboard..."
          aws cloudwatch delete-dashboards --dashboard-names "vanillatstodo-dashboard" || true

          # Delete CloudWatch Alarms
          echo "ðŸ—‘ï¸ Deleting CloudWatch Alarms..."
          ALARMS=$(aws cloudwatch describe-alarms --query "MetricAlarms[?contains(Tags[?Key=='Project'].Value, '${{ env.PROJECT_NAME }}') && contains(Tags[?Key=='Environment'].Value, '${{ env.ENVIRONMENT }}')].AlarmName" --output text)
          if [ ! -z "$ALARMS" ]; then
            for alarm in $ALARMS; do
              aws cloudwatch delete-alarms --alarm-names $alarm
            done
          fi

      - name: Clean Up Network Resources
        id: manual_network_cleanup
        run: |
          # Initialize counters and status tracking
          declare -A CLEANED_COUNT=(
            ["ENDPOINTS"]=0
            ["NAT"]=0
            ["EIP"]=0
            ["INTERFACES"]=0
            ["SECURITY_GROUPS"]=0
            ["ROUTE_TABLES"]=0
            ["NACLS"]=0
            ["SUBNETS"]=0
            ["IGW"]=0
            ["VPC"]=0
          )

          declare -A TOTAL_COUNT=(
            ["ENDPOINTS"]=0
            ["NAT"]=0
            ["EIP"]=0
            ["INTERFACES"]=0
            ["SECURITY_GROUPS"]=0
            ["ROUTE_TABLES"]=0
            ["NACLS"]=0
            ["SUBNETS"]=0
            ["IGW"]=0
            ["VPC"]=0
          )

          # Clean up EIPs with staging-nat pattern
          echo "ðŸ” Finding EIPs with staging-nat pattern..."
          STAGING_EIPS=$(aws ec2 describe-addresses \
            --filters "Name=tag:Name,Values=staging-nat-*" \
            --query 'Addresses[*].AllocationId' \
            --output text || echo "")

          if [ ! -z "$STAGING_EIPS" ]; then
            for eip in $STAGING_EIPS; do
              if [ ! -z "$eip" ]; then
                ((TOTAL_COUNT["EIP"]++))
                EIP_NAME=$(aws ec2 describe-addresses \
                  --allocation-ids $eip \
                  --query 'Addresses[0].Tags[?Key==`Name`].Value' \
                  --output text)
                echo "   Releasing EIP: $EIP_NAME ($eip)"
                if aws ec2 release-address --allocation-id $eip; then
                  ((CLEANED_COUNT["EIP"]++))
                  echo "   âœ… Successfully released EIP: $EIP_NAME"
                else
                  echo "   âš ï¸ Failed to release EIP: $EIP_NAME"
                fi
                sleep 2
              fi
            done
          else
            echo "   No staging NAT EIPs found"
          fi

          echo "ðŸ” Finding all VPCs with vanillatstodo tag..."
          VPC_IDS=$(aws ec2 describe-vpcs \
            --filters "Name=tag:Name,Values=*vanillatstodo*" \
            --query 'Vpcs[*].VpcId' \
            --output text)

          for VPC_ID in $VPC_IDS; do
            ((TOTAL_COUNT["VPC"]++))
            echo "ðŸ”„ Processing VPC: $VPC_ID"

            # 1. VPC Endpoints
            echo "ðŸ—‘ï¸ Cleaning up VPC Endpoints..."
            ENDPOINTS=$(aws ec2 describe-vpc-endpoints \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'VpcEndpoints[*].VpcEndpointId' \
              --output text)
            
            for endpoint in $ENDPOINTS; do
              ((TOTAL_COUNT["ENDPOINTS"]++))
              echo "   Deleting endpoint: $endpoint"
              if aws ec2 delete-vpc-endpoints --vpc-endpoint-ids $endpoint; then
                ((CLEANED_COUNT["ENDPOINTS"]++))
              fi
              sleep 5
            done

            # 2. NAT Gateways
            echo "ðŸ—‘ï¸ Cleaning up NAT Gateways..."
            NAT_IDS=$(aws ec2 describe-nat-gateways \
              --filter "Name=vpc-id,Values=$VPC_ID" \
              --query 'NatGateways[?State!=`deleted`].NatGatewayId' \
              --output text)
            
            for nat in $NAT_IDS; do
              ((TOTAL_COUNT["NAT"]++))
              echo "   Deleting NAT Gateway: $nat"
              if aws ec2 delete-nat-gateway --nat-gateway-id $nat; then
                ((CLEANED_COUNT["NAT"]++))
              fi
            done

            [ ! -z "$NAT_IDS" ] && sleep 45

            # 3. Network Interfaces
            echo "ðŸ—‘ï¸ Cleaning up Network Interfaces..."
            ENI_IDS=$(aws ec2 describe-network-interfaces \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'NetworkInterfaces[*].NetworkInterfaceId' \
              --output text)
            
            for eni in $ENI_IDS; do
              ((TOTAL_COUNT["INTERFACES"]++))
              if aws ec2 describe-network-interfaces \
                --network-interface-ids $eni \
                --query 'NetworkInterfaces[0].Status' \
                --output text | grep -q "available"; then
                echo "   Deleting Network Interface: $eni"
                if aws ec2 delete-network-interface --network-interface-id $eni; then
                  ((CLEANED_COUNT["INTERFACES"]++))
                fi
              fi
              sleep 2
            done

            # 4. Security Groups
            echo "ðŸ—‘ï¸ Cleaning up Security Groups..."
            SG_IDS=$(aws ec2 describe-security-groups \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'SecurityGroups[?GroupName!=`default`].GroupId' \
              --output text)
            
            for sg in $SG_IDS; do
              ((TOTAL_COUNT["SECURITY_GROUPS"]++))
              echo "   Deleting Security Group: $sg"
              if aws ec2 delete-security-group --group-id $sg; then
                ((CLEANED_COUNT["SECURITY_GROUPS"]++))
              fi
              sleep 2
            done

            # 5. Route Tables
            echo "ðŸ—‘ï¸ Cleaning up Route Tables..."
            RT_IDS=$(aws ec2 describe-route-tables \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'RouteTables[?Associations[0].Main!=`true`].RouteTableId' \
              --output text)
            
            for rt in $RT_IDS; do
              ((TOTAL_COUNT["ROUTE_TABLES"]++))
              ASSOC_IDS=$(aws ec2 describe-route-tables \
                --route-table-id $rt \
                --query 'RouteTables[0].Associations[*].RouteTableAssociationId' \
                --output text)
              
              for assoc in $ASSOC_IDS; do
                aws ec2 disassociate-route-table --association-id $assoc
              done
              
              if aws ec2 delete-route-table --route-table-id $rt; then
                ((CLEANED_COUNT["ROUTE_TABLES"]++))
              fi
              sleep 2
            done

            # 6. Network ACLs
            echo "ðŸ—‘ï¸ Cleaning up Network ACLs..."
            NACL_IDS=$(aws ec2 describe-network-acls \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'NetworkAcls[?!IsDefault].NetworkAclId' \
              --output text)
            
            for nacl in $NACL_IDS; do
              ((TOTAL_COUNT["NACLS"]++))
              if aws ec2 delete-network-acl --network-acl-id $nacl; then
                ((CLEANED_COUNT["NACLS"]++))
              fi
              sleep 2
            done

            # 7. Subnets
            echo "ðŸ—‘ï¸ Cleaning up Subnets..."
            SUBNET_IDS=$(aws ec2 describe-subnets \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'Subnets[*].SubnetId' \
              --output text)
            
            for subnet in $SUBNET_IDS; do
              ((TOTAL_COUNT["SUBNETS"]++))
              if aws ec2 delete-subnet --subnet-id $subnet; then
                ((CLEANED_COUNT["SUBNETS"]++))
              fi
              sleep 2
            done

            # 8. Internet Gateway
            echo "ðŸ—‘ï¸ Cleaning up Internet Gateway..."
            IGW_ID=$(aws ec2 describe-internet-gateways \
              --filters "Name=attachment.vpc-id,Values=$VPC_ID" \
              --query 'InternetGateways[*].InternetGatewayId' \
              --output text)
            
            if [ ! -z "$IGW_ID" ] && [ "$IGW_ID" != "None" ]; then
              ((TOTAL_COUNT["IGW"]++))
              if aws ec2 detach-internet-gateway --internet-gateway-id $IGW_ID --vpc-id $VPC_ID && \
                 aws ec2 delete-internet-gateway --internet-gateway-id $IGW_ID; then
                ((CLEANED_COUNT["IGW"]++))
              fi
              sleep 2
            fi

            # 9. VPC
            echo "ðŸ—‘ï¸ Deleting VPC: $VPC_ID"
            if aws ec2 delete-vpc --vpc-id $VPC_ID; then
              ((CLEANED_COUNT["VPC"]++))
            fi
          done

          # Update GitHub Environment variables with counts and status
          {
            for resource in "${!CLEANED_COUNT[@]}"; do
              echo "${resource}_CLEANED=${CLEANED_COUNT[$resource]}" >> $GITHUB_ENV
              echo "${resource}_TOTAL=${TOTAL_COUNT[$resource]}" >> $GITHUB_ENV
              if [ "${CLEANED_COUNT[$resource]}" -eq "${TOTAL_COUNT[$resource]}" ]; then
                echo "NETWORK_${resource}_STATUS=âœ…" >> $GITHUB_ENV
              else
                echo "NETWORK_${resource}_STATUS=âŒ" >> $GITHUB_ENV
              fi
            done

            # Set overall network status
            if [ "${CLEANED_COUNT[VPC]}" -eq "${TOTAL_COUNT[VPC]}" ] && \
               [ "${CLEANED_COUNT[EIP]}" -eq "${TOTAL_COUNT[EIP]}" ]; then
              echo "NETWORK_STATUS=âœ…" >> $GITHUB_ENV
            else
              echo "NETWORK_STATUS=âŒ" >> $GITHUB_ENV
            fi
          }

      - name: Clean Up S3 Resources
        id: s3_cleanup
        run: |
          echo "ðŸ” Finding S3 resources..."

          # List and delete S3 buckets with our project name pattern
          BUCKETS=$(aws s3api list-buckets --query "Buckets[?contains(Name, '${{ env.PROJECT_NAME }}')].Name" --output text)
          if [ ! -z "$BUCKETS" ] && [ "$BUCKETS" != "None" ]; then
            for bucket in $BUCKETS; do
              echo "ðŸ—‘ï¸ Deleting S3 bucket: $bucket"
              aws s3 rb s3://$bucket --force || true
            done
          else
            echo "No S3 buckets found with project name pattern"
          fi

      - name: Clean Up VPC Resources
        id: vpc_cleanup
        run: |
          echo "ðŸ” Finding VPC resources..."

          # List and delete VPCs with our tags
          VPCS=$(aws ec2 describe-vpcs --filters "Name=tag:Project,Values=${{ env.PROJECT_NAME }}" "Name=tag:Environment,Values=${{ env.ENVIRONMENT }}" --query "Vpcs[].VpcId" --output text)
          if [ ! -z "$VPCS" ]; then
            for vpc in $VPCS; do
              echo "ðŸ—‘ï¸ Deleting VPC: $vpc"
              aws ec2 delete-vpc --vpc-id $vpc
            done
          fi

      - name: Summarize Cleanup Status
        if: always()
        run: |
          echo "### Cleanup Summary ðŸ§¹" >> $GITHUB_STEP_SUMMARY
          echo "| Resource | Status | Details |" >> $GITHUB_STEP_SUMMARY
          echo "| -------- | ------ | ------- |" >> $GITHUB_STEP_SUMMARY
          echo "| EKS Cluster | ${EKS_STATUS:-âŒ} | Version: 1.31 |" >> $GITHUB_STEP_SUMMARY
          echo "| CloudWatch | ${CLOUDWATCH_STATUS:-âŒ} | Monitoring |" >> $GITHUB_STEP_SUMMARY

          # Network resources with cleanup details
          echo "| Network - EIP | ${NETWORK_EIP_STATUS:-âŒ} | Cleaned: ${EIP_CLEANED:-0} of ${EIP_TOTAL:-0} |" >> $GITHUB_STEP_SUMMARY
          echo "| Network - VPC Endpoints | ${NETWORK_ENDPOINTS_STATUS:-âŒ} | Cleaned: ${ENDPOINTS_CLEANED:-0} of ${ENDPOINTS_TOTAL:-0} |" >> $GITHUB_STEP_SUMMARY
          echo "| Network - NAT & EIP | ${NETWORK_NAT_STATUS:-âŒ} | Cleaned: ${NATS_CLEANED:-0} of ${NATS_TOTAL:-0} |" >> $GITHUB_STEP_SUMMARY
          echo "| Network - Route Tables | ${NETWORK_ROUTE_STATUS:-âŒ} | Cleaned: ${ROUTES_CLEANED:-0} of ${ROUTES_TOTAL:-0} |" >> $GITHUB_STEP_SUMMARY
          echo "| Network - NACLs | ${NETWORK_NACL_STATUS:-âŒ} | Cleaned: ${NACLS_CLEANED:-0} of ${NACLS_TOTAL:-0} |" >> $GITHUB_STEP_SUMMARY
          echo "| Network - Subnets | ${NETWORK_SUBNET_STATUS:-âŒ} | Cleaned: ${SUBNETS_CLEANED:-0} of ${SUBNETS_TOTAL:-0} |" >> $GITHUB_STEP_SUMMARY
          echo "| Network - IGW | ${NETWORK_IGW_STATUS:-âŒ} | Cleaned: ${IGW_CLEANED:-0} of ${IGW_TOTAL:-0} |" >> $GITHUB_STEP_SUMMARY
          echo "| Network - VPCs | ${NETWORK_VPC_STATUS:-âŒ} | Cleaned: ${VPCS_CLEANED:-0} of ${VPCS_TOTAL:-0} |" >> $GITHUB_STEP_SUMMARY
          echo "| Network - Overall | ${NETWORK_STATUS:-âŒ} | Network Stack |" >> $GITHUB_STEP_SUMMARY

          echo "| S3 State | ${S3_STATUS:-âŒ} | Terraform State |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Configuration:**" >> $GITHUB_STEP_SUMMARY
          echo "- Terraform Version: \`${TF_VERSION}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Region: \`${AWS_REGION}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Project: \`${PROJECT_NAME}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Timestamp: \`$(date -u '+%Y-%m-%d %H:%M:%S UTC')\`" >> $GITHUB_STEP_SUMMARY
