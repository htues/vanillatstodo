name: "Destroy IaC Resources"

"on":
  workflow_dispatch:
    inputs:
      confirmation:
        description: "Type 'destroy' to confirm"
        required: true
        type: string
      environment:
        description: "Environment to destroy (staging/production)"
        required: true
        type: choice
        options:
          - staging
          - production
          - experimental
        default: "staging"

permissions:
  contents: read
  id-token: write

env:
  CLUSTER_NAME: "vanillatstodo-cluster"
  BUCKET_NAME: "vanillatstodo-terraform-state"
  AWS_REGION: "us-east-2"
  TF_VERSION: "1.10.0"
  PROJECT_NAME: "vanillatstodo"
  ENVIRONMENT: ${{ github.event.inputs.environment }}

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  destroy:
    timeout-minutes: 30
    name: "Destroy Infrastructure"
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.confirmation == 'destroy' }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Destroy State Resources
        id: state
        run: |
          cd devops/terraform/00_state
          terraform init -reconfigure \
            -backend-config="bucket=${{ env.BUCKET_NAME }}" \
            -backend-config="key=${{ env.ENVIRONMENT }}/state/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="encrypt=true"
          terraform destroy -auto-approve \
            -var="aws_region=${{ env.AWS_REGION }}" \
            -var="project_name=${{ env.PROJECT_NAME }}" \
            -var="environment=${{ env.ENVIRONMENT }}"

      - name: Destroy Network Resources
        id: network_cleanup
        run: |
          cd devops/terraform/01_network
          terraform init -reconfigure \
            -backend-config="bucket=${{ env.BUCKET_NAME }}" \
            -backend-config="key=${{ env.ENVIRONMENT }}/network/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="encrypt=true"
          terraform destroy -auto-approve \
            -var="aws_region=${{ env.AWS_REGION }}" \
            -var="project_name=${{ env.PROJECT_NAME }}" \
            -var="environment=${{ env.ENVIRONMENT }}"

      - name: Destroy EKS Resources
        id: eks_cleanup
        run: |
          cd devops/terraform/02_eks
          terraform init -reconfigure \
            -backend-config="bucket=${{ env.BUCKET_NAME }}" \
            -backend-config="key=${{ env.ENVIRONMENT }}/eks/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="encrypt=true"
          
          # Check for and force unlock any stale locks
          echo "ðŸ”“ Checking for stale state locks..."
          if terraform plan -detailed-exitcode >/dev/null 2>&1; then
            echo "âœ… No state lock detected"
          else
            echo "âš ï¸ State lock detected, attempting to force unlock..."
            # Try to get the lock ID from the error message
            LOCK_ID=$(terraform plan 2>&1 | grep -o 'ID: [a-f0-9-]*' | cut -d' ' -f2 || echo "")
            if [ ! -z "$LOCK_ID" ]; then
              echo "ðŸ”“ Force unlocking with ID: $LOCK_ID"
              terraform force-unlock -force "$LOCK_ID"
            else
              echo "âš ï¸ Could not determine lock ID, trying generic unlock..."
              terraform force-unlock -force f2e10d17-e3da-6e08-aef1-7a64455b038d || true
            fi
          fi
          
          terraform destroy -auto-approve \
            -var="cluster_name=${{ env.CLUSTER_NAME }}" \
            -var="aws_region=${{ env.AWS_REGION }}" \
            -var="project_name=${{ env.PROJECT_NAME }}" \
            -var="environment=${{ env.ENVIRONMENT }}" \
            -var="cluster_role_name=${{ env.ENVIRONMENT == 'production' && 'production-vanillatstodo-eks-cluster' || 'staging-vanillatstodo-eks-cluster' }}"

      - name: Destroy Monitoring Resources
        id: monitoring_cleanup
        run: |
          cd devops/terraform/03_monitoring
          terraform init -reconfigure \
            -backend-config="bucket=${{ env.BUCKET_NAME }}" \
            -backend-config="key=${{ env.ENVIRONMENT }}/monitoring/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="encrypt=true"
          terraform destroy -auto-approve \
            -var="aws_region=${{ env.AWS_REGION }}" \
            -var="project_name=${{ env.PROJECT_NAME }}" \
            -var="environment=${{ env.ENVIRONMENT }}"

      - name: Clean Up CloudWatch Resources
        id: cloudwatch_cleanup
        run: |
          echo "ðŸ” Finding CloudWatch resources..."

          # Delete CloudWatch Dashboard
          echo "ðŸ—‘ï¸ Deleting CloudWatch Dashboard..."
          aws cloudwatch delete-dashboards --dashboard-names "vanillatstodo-dashboard" || true

          # Delete CloudWatch Alarms
          echo "ðŸ—‘ï¸ Deleting CloudWatch Alarms..."
          ALARMS=$(aws cloudwatch describe-alarms --query "MetricAlarms[?contains(Tags[?Key=='Project'].Value, '${{ env.PROJECT_NAME }}') && contains(Tags[?Key=='Environment'].Value, '${{ env.ENVIRONMENT }}')].AlarmName" --output text)
          if [ ! -z "$ALARMS" ]; then
            for alarm in $ALARMS; do
              aws cloudwatch delete-alarms --alarm-names $alarm
            done
          fi

      - name: Clean Up Network Resources
        id: manual_network_cleanup
        run: |
          # Initialize counters and status tracking
          declare -A CLEANED_COUNT=(
            ["ENDPOINTS"]=0
            ["NAT"]=0
            ["EIP"]=0
            ["INTERFACES"]=0
            ["SECURITY_GROUPS"]=0
            ["ROUTE_TABLES"]=0
            ["NACLS"]=0
            ["SUBNETS"]=0
            ["IGW"]=0
            ["VPC"]=0
          )

          declare -A TOTAL_COUNT=(
            ["ENDPOINTS"]=0
            ["NAT"]=0
            ["EIP"]=0
            ["INTERFACES"]=0
            ["SECURITY_GROUPS"]=0
            ["ROUTE_TABLES"]=0
            ["NACLS"]=0
            ["SUBNETS"]=0
            ["IGW"]=0
            ["VPC"]=0
          )

          # Clean up EIPs with staging-nat pattern
          echo "ðŸ” Finding EIPs with staging-nat pattern..."
          STAGING_EIPS=$(aws ec2 describe-addresses \
            --filters "Name=tag:Name,Values=staging-nat-*" \
            --query 'Addresses[*].AllocationId' \
            --output text || echo "")

          if [ ! -z "$STAGING_EIPS" ]; then
            for eip in $STAGING_EIPS; do
              if [ ! -z "$eip" ]; then
                ((TOTAL_COUNT["EIP"]++))
                EIP_NAME=$(aws ec2 describe-addresses \
                  --allocation-ids $eip \
                  --query 'Addresses[0].Tags[?Key==`Name`].Value' \
                  --output text)
                echo "   Releasing EIP: $EIP_NAME ($eip)"
                if aws ec2 release-address --allocation-id $eip; then
                  ((CLEANED_COUNT["EIP"]++))
                  echo "   âœ… Successfully released EIP: $EIP_NAME"
                else
                  echo "   âš ï¸ Failed to release EIP: $EIP_NAME"
                fi
                sleep 2
              fi
            done
          else
            echo "   No staging NAT EIPs found"
          fi

          echo "ðŸ” Finding all VPCs with vanillatstodo tag..."
          VPC_IDS=$(aws ec2 describe-vpcs \
            --filters "Name=tag:Name,Values=*vanillatstodo*" \
            --query 'Vpcs[*].VpcId' \
            --output text)

          for VPC_ID in $VPC_IDS; do
            ((TOTAL_COUNT["VPC"]++))
            echo "ðŸ”„ Processing VPC: $VPC_ID"

            # 1. VPC Endpoints
            echo "ðŸ—‘ï¸ Cleaning up VPC Endpoints..."
            ENDPOINTS=$(aws ec2 describe-vpc-endpoints \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'VpcEndpoints[*].VpcEndpointId' \
              --output text)
            
            for endpoint in $ENDPOINTS; do
              ((TOTAL_COUNT["ENDPOINTS"]++))
              echo "   Deleting endpoint: $endpoint"
              if aws ec2 delete-vpc-endpoints --vpc-endpoint-ids $endpoint; then
                ((CLEANED_COUNT["ENDPOINTS"]++))
              fi
              sleep 5
            done

            # 2. NAT Gateways
            echo "ðŸ—‘ï¸ Cleaning up NAT Gateways..."
            NAT_IDS=$(aws ec2 describe-nat-gateways \
              --filter "Name=vpc-id,Values=$VPC_ID" \
              --query 'NatGateways[?State!=`deleted`].NatGatewayId' \
              --output text)
            
            for nat in $NAT_IDS; do
              ((TOTAL_COUNT["NAT"]++))
              echo "   Deleting NAT Gateway: $nat"
              if aws ec2 delete-nat-gateway --nat-gateway-id $nat; then
                ((CLEANED_COUNT["NAT"]++))
              fi
            done

            [ ! -z "$NAT_IDS" ] && sleep 45

            # 3. Network Interfaces
            echo "ðŸ—‘ï¸ Cleaning up Network Interfaces..."
            ENI_IDS=$(aws ec2 describe-network-interfaces \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'NetworkInterfaces[*].NetworkInterfaceId' \
              --output text)
            
            for eni in $ENI_IDS; do
              ((TOTAL_COUNT["INTERFACES"]++))
              if aws ec2 describe-network-interfaces \
                --network-interface-ids $eni \
                --query 'NetworkInterfaces[0].Status' \
                --output text | grep -q "available"; then
                echo "   Deleting Network Interface: $eni"
                if aws ec2 delete-network-interface --network-interface-id $eni; then
                  ((CLEANED_COUNT["INTERFACES"]++))
                fi
              fi
              sleep 2
            done

            # 4. Security Groups
            echo "ðŸ—‘ï¸ Cleaning up Security Groups..."
            SG_IDS=$(aws ec2 describe-security-groups \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'SecurityGroups[?GroupName!=`default`].GroupId' \
              --output text)
            
            for sg in $SG_IDS; do
              ((TOTAL_COUNT["SECURITY_GROUPS"]++))
              echo "   Deleting Security Group: $sg"
              if aws ec2 delete-security-group --group-id $sg; then
                ((CLEANED_COUNT["SECURITY_GROUPS"]++))
              fi
              sleep 2
            done

            # 5. Route Tables
            echo "ðŸ—‘ï¸ Cleaning up Route Tables..."
            RT_IDS=$(aws ec2 describe-route-tables \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'RouteTables[?Associations[0].Main!=`true`].RouteTableId' \
              --output text)
            
            for rt in $RT_IDS; do
              ((TOTAL_COUNT["ROUTE_TABLES"]++))
              ASSOC_IDS=$(aws ec2 describe-route-tables \
                --route-table-id $rt \
                --query 'RouteTables[0].Associations[*].RouteTableAssociationId' \
                --output text)
              
              for assoc in $ASSOC_IDS; do
                aws ec2 disassociate-route-table --association-id $assoc
              done
              
              if aws ec2 delete-route-table --route-table-id $rt; then
                ((CLEANED_COUNT["ROUTE_TABLES"]++))
              fi
              sleep 2
            done

            # 6. Network ACLs
            echo "ðŸ—‘ï¸ Cleaning up Network ACLs..."
            NACL_IDS=$(aws ec2 describe-network-acls \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'NetworkAcls[?!IsDefault].NetworkAclId' \
              --output text)
            
            for nacl in $NACL_IDS; do
              ((TOTAL_COUNT["NACLS"]++))
              if aws ec2 delete-network-acl --network-acl-id $nacl; then
                ((CLEANED_COUNT["NACLS"]++))
              fi
              sleep 2
            done

            # 7. Subnets
            echo "ðŸ—‘ï¸ Cleaning up Subnets..."
            SUBNET_IDS=$(aws ec2 describe-subnets \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'Subnets[*].SubnetId' \
              --output text)
            
            for subnet in $SUBNET_IDS; do
              ((TOTAL_COUNT["SUBNETS"]++))
              if aws ec2 delete-subnet --subnet-id $subnet; then
                ((CLEANED_COUNT["SUBNETS"]++))
              fi
              sleep 2
            done

            # 8. Internet Gateway
            echo "ðŸ—‘ï¸ Cleaning up Internet Gateway..."
            IGW_ID=$(aws ec2 describe-internet-gateways \
              --filters "Name=attachment.vpc-id,Values=$VPC_ID" \
              --query 'InternetGateways[*].InternetGatewayId' \
              --output text)
            
            if [ ! -z "$IGW_ID" ] && [ "$IGW_ID" != "None" ]; then
              ((TOTAL_COUNT["IGW"]++))
              if aws ec2 detach-internet-gateway --internet-gateway-id $IGW_ID --vpc-id $VPC_ID && \
                 aws ec2 delete-internet-gateway --internet-gateway-id $IGW_ID; then
                ((CLEANED_COUNT["IGW"]++))
              fi
              sleep 2
            fi

            # 9. VPC
            echo "ðŸ—‘ï¸ Deleting VPC: $VPC_ID"
            if aws ec2 delete-vpc --vpc-id $VPC_ID; then
              ((CLEANED_COUNT["VPC"]++))
            fi
          done

          # Update GitHub Environment variables with counts and status
          {
            for resource in "${!CLEANED_COUNT[@]}"; do
              echo "${resource}_CLEANED=${CLEANED_COUNT[$resource]}" >> $GITHUB_ENV
              echo "${resource}_TOTAL=${TOTAL_COUNT[$resource]}" >> $GITHUB_ENV
              if [ "${CLEANED_COUNT[$resource]}" -eq "${TOTAL_COUNT[$resource]}" ]; then
                echo "NETWORK_${resource}_STATUS=âœ…" >> $GITHUB_ENV
              else
                echo "NETWORK_${resource}_STATUS=âŒ" >> $GITHUB_ENV
              fi
            done

            # Set overall network status
            if [ "${CLEANED_COUNT[VPC]}" -eq "${TOTAL_COUNT[VPC]}" ] && \
               [ "${CLEANED_COUNT[EIP]}" -eq "${TOTAL_COUNT[EIP]}" ]; then
              echo "NETWORK_STATUS=âœ…" >> $GITHUB_ENV
            else
              echo "NETWORK_STATUS=âŒ" >> $GITHUB_ENV
            fi
          }

      - name: Clean Up S3 Resources
        id: s3_cleanup
        run: |
          echo "ðŸ” Finding S3 resources..."

          # List and delete S3 buckets with our tags
          BUCKETS=$(aws s3api list-buckets --query "Buckets[?contains(Tags[?Key=='Project'].Value, '${{ env.PROJECT_NAME }}') && contains(Tags[?Key=='Environment'].Value, '${{ env.ENVIRONMENT }}')].Name" --output text)
          if [ ! -z "$BUCKETS" ]; then
            for bucket in $BUCKETS; do
              echo "ðŸ—‘ï¸ Deleting S3 bucket: $bucket"
              aws s3 rb s3://$bucket --force
            done
          fi

      - name: Clean Up IAM Resources
        id: iam_cleanup
        run: |
          echo "ðŸ” Finding IAM resources..."

          # Delete IAM roles with our tags
          ROLES=$(aws iam list-roles --query "Roles[?contains(Tags[?Key=='Project'].Value, '${{ env.PROJECT_NAME }}') && contains(Tags[?Key=='Environment'].Value, '${{ env.ENVIRONMENT }}')].RoleName" --output text)
          if [ ! -z "$ROLES" ]; then
            for role in $ROLES; do
              echo "ðŸ—‘ï¸ Deleting IAM role: $role"
              # Detach all policies first
              POLICIES=$(aws iam list-attached-role-policies --role-name $role --query "AttachedPolicies[].PolicyArn" --output text)
              for policy in $POLICIES; do
                aws iam detach-role-policy --role-name $role --policy-arn $policy
              done
              aws iam delete-role --role-name $role
            done
          fi

      - name: Clean Up VPC Resources
        id: vpc_cleanup
        run: |
          echo "ðŸ” Finding VPC resources..."

          # List and delete VPCs with our tags
          VPCS=$(aws ec2 describe-vpcs --filters "Name=tag:Project,Values=${{ env.PROJECT_NAME }}" "Name=tag:Environment,Values=${{ env.ENVIRONMENT }}" --query "Vpcs[].VpcId" --output text)
          if [ ! -z "$VPCS" ]; then
            for vpc in $VPCS; do
              echo "ðŸ—‘ï¸ Deleting VPC: $vpc"
              aws ec2 delete-vpc --vpc-id $vpc
            done
          fi

      - name: Summarize Cleanup Status
        if: always()
        run: |
          echo "### Cleanup Summary ðŸ§¹" >> $GITHUB_STEP_SUMMARY
          echo "| Resource | Status | Details |" >> $GITHUB_STEP_SUMMARY
          echo "| -------- | ------ | ------- |" >> $GITHUB_STEP_SUMMARY
          echo "| EKS Cluster | ${EKS_STATUS:-âŒ} | Version: 1.31 |" >> $GITHUB_STEP_SUMMARY
          echo "| CloudWatch | ${CLOUDWATCH_STATUS:-âŒ} | Monitoring |" >> $GITHUB_STEP_SUMMARY

          # Network resources with cleanup details
          echo "| Network - EIP | ${NETWORK_EIP_STATUS:-âŒ} | Cleaned: ${EIP_CLEANED:-0} of ${EIP_TOTAL:-0} |" >> $GITHUB_STEP_SUMMARY
          echo "| Network - VPC Endpoints | ${NETWORK_ENDPOINTS_STATUS:-âŒ} | Cleaned: ${ENDPOINTS_CLEANED:-0} of ${ENDPOINTS_TOTAL:-0} |" >> $GITHUB_STEP_SUMMARY
          echo "| Network - NAT & EIP | ${NETWORK_NAT_STATUS:-âŒ} | Cleaned: ${NATS_CLEANED:-0} of ${NATS_TOTAL:-0} |" >> $GITHUB_STEP_SUMMARY
          echo "| Network - Route Tables | ${NETWORK_ROUTE_STATUS:-âŒ} | Cleaned: ${ROUTES_CLEANED:-0} of ${ROUTES_TOTAL:-0} |" >> $GITHUB_STEP_SUMMARY
          echo "| Network - NACLs | ${NETWORK_NACL_STATUS:-âŒ} | Cleaned: ${NACLS_CLEANED:-0} of ${NACLS_TOTAL:-0} |" >> $GITHUB_STEP_SUMMARY
          echo "| Network - Subnets | ${NETWORK_SUBNET_STATUS:-âŒ} | Cleaned: ${SUBNETS_CLEANED:-0} of ${SUBNETS_TOTAL:-0} |" >> $GITHUB_STEP_SUMMARY
          echo "| Network - IGW | ${NETWORK_IGW_STATUS:-âŒ} | Cleaned: ${IGW_CLEANED:-0} of ${IGW_TOTAL:-0} |" >> $GITHUB_STEP_SUMMARY
          echo "| Network - VPCs | ${NETWORK_VPC_STATUS:-âŒ} | Cleaned: ${VPCS_CLEANED:-0} of ${VPCS_TOTAL:-0} |" >> $GITHUB_STEP_SUMMARY
          echo "| Network - Overall | ${NETWORK_STATUS:-âŒ} | Network Stack |" >> $GITHUB_STEP_SUMMARY

          echo "| S3 State | ${S3_STATUS:-âŒ} | Terraform State |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Configuration:**" >> $GITHUB_STEP_SUMMARY
          echo "- Terraform Version: \`${TF_VERSION}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Region: \`${AWS_REGION}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Project: \`${PROJECT_NAME}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Timestamp: \`$(date -u '+%Y-%m-%d %H:%M:%S UTC')\`" >> $GITHUB_STEP_SUMMARY
