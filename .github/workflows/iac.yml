name: Deploy Infrastructure as Code

on:
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
    outputs:
      cluster_status:
        value: ${{ jobs.deploy.outputs.cluster_status }}
      cluster_endpoint:
        value: ${{ jobs.deploy.outputs.cluster_endpoint }}
      cluster_name:
        value: ${{ jobs.deploy.outputs.cluster_name }}

permissions:
  id-token: write
  contents: read
  deployments: write

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}

    outputs:
      cluster_status: ${{ env.EKS_STATUS }}
      cluster_endpoint: ${{ steps.eks_output.outputs.cluster_endpoint }}
      cluster_name: ${{ env.CLUSTER_NAME }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Load Environment Variables
        run: |
          cat .github/variables/environment.env >> $GITHUB_ENV

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Validate Region
        run: |
          # Get current region from AWS CLI configuration or environment
          CURRENT_REGION=${AWS_DEFAULT_REGION:-$(aws configure get region)}
          if [ "$CURRENT_REGION" != "${{ env.AWS_REGION }}" ]; then
            echo "‚ùå Wrong region configured: $CURRENT_REGION. Must be ${{ env.AWS_REGION }}"
            exit 1
          fi
          echo "‚úÖ Region validated: ${{ env.AWS_REGION }}"

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Test IAM Permissions
        run: |
          chmod +x ./devops/scripts/test_aws_permit.sh
          ./devops/scripts/test_aws_permit.sh

      - name: Setup Infrastructure Prerequisites
        run: |
          chmod +x ./devops/scripts/infra-manager.sh        
          ./devops/scripts/infra-manager.sh verify

      - name: Deploy State Resources
        working-directory: devops/terraform/00_state
        run: |
          rm -rf .terraform*
          terraform init

          if ! aws s3 ls "s3://${PROJECT_NAME}-terraform-state" 2>/dev/null; then
            echo "üèóÔ∏è Creating state bucket..."
            terraform apply -auto-approve
            echo "STATE_STATUS=‚úÖ" >> $GITHUB_ENV
          else
            echo "‚úÖ State bucket exists"
            echo "STATE_STATUS=‚úÖ" >> $GITHUB_ENV
          fi

      - name: Deploy Network Layer
        working-directory: devops/terraform/01_network
        run: |
          echo "üîß Deploying network layer..."

          # Initialize backend
          terraform init \
            -backend-config="bucket=${PROJECT_NAME}-terraform-state" \
            -backend-config="key=staging/network.tfstate" \
            -backend-config="region=${AWS_REGION}" \
            -backend-config="encrypt=true"

          # Plan and apply
          terraform plan -out=tfplan
          terraform apply tfplan

          # Get state location
          STATE_FILE=$(terraform workspace show)
          if [ -f ".terraform/terraform.tfstate" ]; then
            STATE_PATH=".terraform/terraform.tfstate"
          elif [ -f "terraform.tfstate" ]; then
            STATE_PATH="terraform.tfstate"
          else
            echo "‚ùå Cannot find state file"
            exit 1
          fi

          # Upload state to S3
          echo "üì§ Uploading state to S3..."
          aws s3 cp "${STATE_PATH}" "s3://${PROJECT_NAME}-terraform-state/staging/network.tfstate"

          if [ $? -eq 0 ]; then
            echo "‚úÖ State uploaded successfully"
            
            # Verify state file in S3
            if aws s3 ls "s3://${PROJECT_NAME}-terraform-state/staging/network.tfstate"; then
              echo "‚úÖ State file verified in S3"
            else
              echo "‚ùå State file not found in S3 after upload"
              exit 1
            fi
          else
            echo "‚ùå Failed to upload state"
            exit 1
          fi

      - name: Deploy EKS Layer
        working-directory: devops/terraform/02_eks
        run: |
          echo "üîß Deploying EKS layer..."

          # Clean previous state
          rm -rf .terraform*

          # Download and verify network state
          aws s3 cp "s3://${PROJECT_NAME}-terraform-state/staging/network.tfstate" ./network.tfstate

          # Show network state for debugging
          echo "üìä Network state content:"
          cat network.tfstate | jq '.outputs'

          # Initialize terraform
          terraform init \
            -backend-config="bucket=${PROJECT_NAME}-terraform-state" \
            -backend-config="key=staging/eks.tfstate" \
            -backend-config="region=${AWS_REGION}" \
            -backend-config="encrypt=true"

          # Test remote state data
          echo "üîç Testing remote state access:"
          terraform console <<EOF
          data.terraform_remote_state.network.outputs
          EOF

          # Deploy if state is accessible
          terraform plan -out=tfplan
          terraform apply tfplan

      - name: Deploy Monitoring
        working-directory: ./devops/terraform/03_monitoring
        run: |
          echo "üîç Checking for existing log group..."
          MONITORING_STATUS="‚ùå"

          # Initialize Terraform
          terraform init \
            -backend-config="bucket=vanillatstodo-terraform-state" \
            -backend-config="key=staging/monitoring.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="encrypt=true"

          # Check and import log group if exists
          if aws logs describe-log-groups \
            --log-group-name-prefix "/aws/eks/vanillatstodo-cluster/cluster" \
            --query 'logGroups[0].logGroupName' \
            --output text | grep -q "vanillatstodo-cluster"; then
            terraform import aws_cloudwatch_log_group.eks /aws/eks/vanillatstodo-cluster/cluster || true
          fi

          # Plan and apply
          if terraform plan -detailed-exitcode -out=tfplan; then
            if terraform apply tfplan; then
              MONITORING_STATUS="‚úÖ"
            fi
          fi

          echo "MONITORING_STATUS=${MONITORING_STATUS}" >> $GITHUB_ENV

      - name: Verify EKS Deployment
        if: success()
        working-directory: ./devops/terraform/02_eks
        run: |
          CLUSTER_INFO=$(aws eks describe-cluster --name vanillatstodo-cluster --region ${{ env.AWS_REGION }})
          CLUSTER_STATUS=$(echo "$CLUSTER_INFO" | jq -r '.cluster.status')
          CLUSTER_VERSION=$(echo "$CLUSTER_INFO" | jq -r '.cluster.version')

          if [ "$CLUSTER_STATUS" != "ACTIVE" ]; then
            echo "‚ùå Cluster is not active. Status: $CLUSTER_STATUS"
            exit 1
          fi

          if [ "$CLUSTER_VERSION" != "1.31" ]; then
            echo "‚ùå Wrong cluster version: $CLUSTER_VERSION. Expected: 1.31"
            exit 1
          fi

          echo "‚úÖ EKS Cluster validated:"
          echo "- Status: $CLUSTER_STATUS"
          echo "- Version: $CLUSTER_VERSION"
          echo "- Region: ${{ env.AWS_REGION }}"

      - name: Export EKS Details
        id: eks_output
        if: success()
        run: |
          ENDPOINT=$(aws eks describe-cluster \
            --name ${{ env.CLUSTER_NAME }} \
            --query "cluster.endpoint" \
            --output text)
          echo "cluster_endpoint=${ENDPOINT}" >> $GITHUB_OUTPUT
